"use strict";
(self["webpackChunk"] = self["webpackChunk"] || []).push([["node_modules_thirdweb-dev_wallets_evm_connectors_trust_dist_thirdweb-dev-wallets-evm-connecto-2c16fe"],{

/***/ "./node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-60b19604.browser.esm.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-60b19604.browser.esm.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   W: () => (/* binding */ WagmiConnector)
/* harmony export */ });
/* harmony import */ var _defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defineProperty-c8ecdc07.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/defineProperty-c8ecdc07.browser.esm.js");
/* harmony import */ var _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @thirdweb-dev/chains */ "./node_modules/@thirdweb-dev/chains/dist/thirdweb-dev-chains.browser.esm.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");




class WagmiConnector extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__["default"] {
  /** Unique connector id */

  /** Connector name */

  /** Chains connector supports */

  /** Options to use with connector */

  /** Whether connector is usable */

  constructor(_ref) {
    let {
      chains = _thirdweb_dev_chains__WEBPACK_IMPORTED_MODULE_1__.defaultChains,
      options
    } = _ref;
    super();
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__._)(this, "id", void 0);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__._)(this, "name", void 0);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__._)(this, "chains", void 0);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__._)(this, "options", void 0);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__._)(this, "ready", void 0);
    this.chains = chains;
    this.options = options;
  }
  getBlockExplorerUrls(chain) {
    const explorers = chain.explorers?.map(x => x.url) ?? [];
    return explorers.length > 0 ? explorers : undefined;
  }
  isChainUnsupported(chainId) {
    return !this.chains.some(x => x.chainId === chainId);
  }
  updateChains(chains) {
    this.chains = chains;
  }
}




/***/ }),

/***/ "./node_modules/@thirdweb-dev/wallets/dist/errors-4bdf81d2.browser.esm.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/dist/errors-4bdf81d2.browser.esm.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AddChainError),
/* harmony export */   C: () => (/* binding */ ChainNotConfiguredError),
/* harmony export */   P: () => (/* binding */ ProviderRpcError),
/* harmony export */   R: () => (/* binding */ ResourceUnavailableError),
/* harmony export */   S: () => (/* binding */ SwitchChainError),
/* harmony export */   U: () => (/* binding */ UserRejectedRequestError),
/* harmony export */   a: () => (/* binding */ ConnectorNotFoundError)
/* harmony export */ });
/* harmony import */ var _defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty-c8ecdc07.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/defineProperty-c8ecdc07.browser.esm.js");


/**
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors per EIP-1474.
 * @see https://eips.ethereum.org/EIPS/eip-1474
 */
class RpcError extends Error {
  constructor( /** Human-readable string */
  message, options) {
    const {
      cause,
      code,
      data
    } = options;
    if (!Number.isInteger(code)) {
      throw new Error('"code" must be an integer.');
    }
    if (!message || typeof message !== "string") {
      throw new Error('"message" must be a nonempty string.');
    }
    super(`${message}. Cause: ${cause}`);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "cause", void 0);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "code", void 0);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "data", void 0);
    this.cause = cause;
    this.code = code;
    this.data = data;
  }
}

/**
 * Error subclass implementing Ethereum Provider errors per EIP-1193.
 * @see https://eips.ethereum.org/EIPS/eip-1193
 */
class ProviderRpcError extends RpcError {
  /**
   * Create an Ethereum Provider JSON-RPC error.
   * `code` must be an integer in the 1000 <= 4999 range.
   */
  constructor( /** Human-readable string */
  message, options) {
    const {
      cause,
      code,
      data
    } = options;
    if (!(Number.isInteger(code) && code >= 1000 && code <= 4999)) {
      throw new Error('"code" must be an integer such that: 1000 <= code <= 4999');
    }
    super(message, {
      cause,
      code,
      data
    });
  }
}
class AddChainError extends Error {
  constructor() {
    super(...arguments);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "name", "AddChainError");
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "message", "Error adding chain");
  }
}
class ChainNotConfiguredError extends Error {
  constructor(_ref) {
    let {
      chainId,
      connectorId
    } = _ref;
    super(`Chain "${chainId}" not configured for connector "${connectorId}".`);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "name", "ChainNotConfigured");
  }
}
class ConnectorNotFoundError extends Error {
  constructor() {
    super(...arguments);
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "name", "ConnectorNotFoundError");
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "message", "Connector not found");
  }
}
class ResourceUnavailableError extends RpcError {
  constructor(cause) {
    super("Resource unavailable", {
      cause,
      code: -32002
    });
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "name", "ResourceUnavailable");
  }
}
class SwitchChainError extends ProviderRpcError {
  constructor(cause) {
    super("Error switching chain", {
      cause,
      code: 4902
    });
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "name", "SwitchChainError");
  }
}
class UserRejectedRequestError extends ProviderRpcError {
  constructor(cause) {
    super("User rejected request", {
      cause,
      code: 4001
    });
    (0,_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(this, "name", "UserRejectedRequestError");
  }
}

// Ethers does not have an error type so we can use this for casting
// https://github.com/ethers-io/ethers.js/blob/main/packages/logger/src.ts/index.ts#L268




/***/ }),

/***/ "./node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-e4cc0175.browser.esm.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-e4cc0175.browser.esm.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   n: () => (/* binding */ normalizeChainId)
/* harmony export */ });
function normalizeChainId(chainId) {
  if (typeof chainId === "string") {
    return Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
  }
  if (typeof chainId === "bigint") {
    return Number(chainId);
  }
  return chainId;
}




/***/ }),

/***/ "./node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js":
/*!*************************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js ***!
  \*************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InjectedConnector: () => (/* binding */ InjectedConnector)
/* harmony export */ });
/* harmony import */ var _dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../dist/classPrivateFieldSet-a5db7c83.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/classPrivateFieldSet-a5db7c83.browser.esm.js");
/* harmony import */ var _dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../dist/defineProperty-c8ecdc07.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/defineProperty-c8ecdc07.browser.esm.js");
/* harmony import */ var _dist_assertWindowEthereum_66ccef46_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/assertWindowEthereum-66ccef46.browser.esm.js");
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ethers */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ethers */ "./node_modules/@ethersproject/providers/lib.esm/web3-provider.js");
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ethers */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _dist_WagmiConnector_60b19604_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../dist/WagmiConnector-60b19604.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/WagmiConnector-60b19604.browser.esm.js");
/* harmony import */ var _dist_normalizeChainId_e4cc0175_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../dist/normalizeChainId-e4cc0175.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/normalizeChainId-e4cc0175.browser.esm.js");
/* harmony import */ var _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../../dist/errors-4bdf81d2.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/errors-4bdf81d2.browser.esm.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");










function getInjectedName(ethereum) {
  if (!ethereum) {
    return "Injected";
  }
  const getName = provider => {
    if (provider.isAvalanche) {
      return "Core Wallet";
    }
    if (provider.isBitKeep) {
      return "BitKeep";
    }
    if (provider.isBraveWallet) {
      return "Brave Wallet";
    }
    if (provider.isCoinbaseWallet) {
      return "Coinbase Wallet";
    }
    if (provider.isExodus) {
      return "Exodus";
    }
    if (provider.isFrame) {
      return "Frame";
    }
    if (provider.isKuCoinWallet) {
      return "KuCoin Wallet";
    }
    if (provider.isMathWallet) {
      return "MathWallet";
    }
    if (provider.isOneInchIOSWallet || provider.isOneInchAndroidWallet) {
      return "1inch Wallet";
    }
    if (provider.isOpera) {
      return "Opera";
    }
    if (provider.isPortal) {
      return "Ripio Portal";
    }
    if (provider.isTally) {
      return "Tally";
    }
    if (provider.isTokenPocket) {
      return "TokenPocket";
    }
    if (provider.isTokenary) {
      return "Tokenary";
    }
    if (provider.isTrust || provider.isTrustWallet) {
      return "Trust Wallet";
    }
    if (provider.isMetaMask) {
      return "MetaMask";
    }
  };

  // Some injected providers detect multiple other providers and create a list at `ethers.providers`
  if (ethereum.providers?.length) {
    // Deduplicate names using Set
    // Coinbase Wallet puts multiple providers in `ethereum.providers`
    const nameSet = new Set();
    let unknownCount = 1;
    for (const provider of ethereum.providers) {
      let name = getName(provider);
      if (!name) {
        name = `Unknown Wallet #${unknownCount}`;
        unknownCount += 1;
      }
      nameSet.add(name);
    }
    const names = [...nameSet];
    if (names.length) {
      return names;
    }
    return names[0] ?? "Injected";
  }
  return getName(ethereum) ?? "Injected";
}

var _provider = /*#__PURE__*/new WeakMap();
class InjectedConnector extends _dist_WagmiConnector_60b19604_browser_esm_js__WEBPACK_IMPORTED_MODULE_1__.W {
  /**
   * Name of the injected connector
   */

  /**
   * Whether the connector is ready to be used
   *
   * `true` if the injected provider is found
   */

  constructor(arg) {
    const defaultOptions = {
      shimDisconnect: true,
      getProvider: () => {
        if ((0,_dist_assertWindowEthereum_66ccef46_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(globalThis.window)) {
          return globalThis.window.ethereum;
        }
      }
    };
    const options = {
      ...defaultOptions,
      ...arg.options
    };
    super({
      chains: arg.chains,
      options
    });
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "id", void 0);
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "name", void 0);
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "ready", void 0);
    (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(this, _provider, {
      writable: true,
      value: void 0
    });
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "connectorStorage", void 0);
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "shimDisconnectKey", "injected.shimDisconnect");
    /**
     * handles the `accountsChanged` event from the provider
     * * emits `change` event if connected to a different account
     * * emits `disconnect` event if no accounts available
     */
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "onAccountsChanged", async accounts => {
      if (accounts.length === 0) {
        this.emit("disconnect");
      } else {
        this.emit("change", {
          account: ethers__WEBPACK_IMPORTED_MODULE_5__.getAddress(accounts[0])
        });
      }
    });
    /**
     * handles the `chainChanged` event from the provider
     * * emits `change` event if connected to a different chain
     */
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "onChainChanged", chainId => {
      const id = (0,_dist_normalizeChainId_e4cc0175_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.n)(chainId);
      const unsupported = this.isChainUnsupported(id);
      this.emit("change", {
        chain: {
          id,
          unsupported
        }
      });
    });
    /**
     * handles the `disconnect` event from the provider
     * * emits `disconnect` event
     */
    (0,_dist_defineProperty_c8ecdc07_browser_esm_js__WEBPACK_IMPORTED_MODULE_3__._)(this, "onDisconnect", async error => {
      // We need this as MetaMask can emit the "disconnect" event upon switching chains.
      // If MetaMask emits a `code: 1013` error, wait for reconnection before disconnecting
      // https://github.com/MetaMask/providers/pull/120
      if (error.code === 1013) {
        const provider = await this.getProvider();
        if (provider) {
          const isAuthorized = await this.getAccount();
          if (isAuthorized) {
            return;
          }
        }
      }
      this.emit("disconnect");

      // Remove `shimDisconnect` => it signals that wallet is disconnected
      if (this.options.shimDisconnect) {
        await this.connectorStorage.removeItem(this.shimDisconnectKey);
      }
    });
    const _provider2 = options.getProvider();

    // set the name of the connector
    if (typeof options.name === "string") {
      // if name is given, use that
      this.name = options.name;
    } else if (_provider2) {
      // if injected provider is detected, get name from it
      const detectedName = getInjectedName(_provider2);
      if (options.name) {
        this.name = options.name(detectedName);
      } else {
        if (typeof detectedName === "string") {
          this.name = detectedName;
        } else {
          this.name = detectedName[0];
        }
      }
    } else {
      // else default to "Injected"
      this.name = "Injected";
    }
    this.id = "injected";
    this.ready = !!_provider2;
    this.connectorStorage = arg.connectorStorage;
  }

  /**
   * * Connect to the injected provider
   * * switch to the given chain if `chainId` is specified as an argument
   */
  async connect() {
    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    try {
      const provider = await this.getProvider();
      if (!provider) {
        throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a();
      }
      this.setupListeners();

      // emit "connecting" event
      this.emit("message", {
        type: "connecting"
      });

      // request account addresses from injected provider
      const accountAddresses = await provider.request({
        method: "eth_requestAccounts"
      });

      // get the first account address
      const firstAccountAddress = ethers__WEBPACK_IMPORTED_MODULE_5__.getAddress(accountAddresses[0]);

      // Switch to given chain if a chainId is specified
      let connectedChainId = await this.getChainId();
      // Check if currently connected chain is unsupported
      // chainId is considered unsupported if chainId is not in the list of this.chains array
      let isUnsupported = this.isChainUnsupported(connectedChainId);

      // if chainId is specified and it is not the same as the currently connected chain
      if (options.chainId && connectedChainId !== options.chainId) {
        // switch to the given chain
        try {
          await this.switchChain(options.chainId);
          // recalculate connectedChainId and isUnsupported
          connectedChainId = options.chainId;
          isUnsupported = this.isChainUnsupported(options.chainId);
        } catch (e) {
          console.error(`Could not switch to chain id: ${options.chainId}`, e);
        }
      }

      // if shimDisconnect is enabled
      if (this.options.shimDisconnect) {
        // add the shim shimDisconnectKey => it signals that wallet is connected
        await this.connectorStorage.setItem(this.shimDisconnectKey, "true");
      }
      const connectionInfo = {
        account: firstAccountAddress,
        chain: {
          id: connectedChainId,
          unsupported: isUnsupported
        },
        provider
      };
      this.emit("connect", connectionInfo);
      return connectionInfo;
    } catch (error) {
      if (this.isUserRejectedRequestError(error)) {
        throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.U(error);
      }
      if (error.code === -32002) {
        throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.R(error);
      }
      throw error;
    }
  }

  /**
   * disconnect from the injected provider
   */
  async disconnect() {
    // perform cleanup
    const provider = await this.getProvider();
    if (!provider?.removeListener) {
      return;
    }
    provider.removeListener("accountsChanged", this.onAccountsChanged);
    provider.removeListener("chainChanged", this.onChainChanged);
    provider.removeListener("disconnect", this.onDisconnect);

    // if shimDisconnect is enabled
    if (this.options.shimDisconnect) {
      // Remove the shimDisconnectKey => it signals that wallet is disconnected
      await this.connectorStorage.removeItem(this.shimDisconnectKey);
    }
  }

  /**
   * @returns The first account address from the injected provider
   */
  async getAccount() {
    const provider = await this.getProvider();
    if (!provider) {
      throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a();
    }
    const accounts = await provider.request({
      method: "eth_accounts"
    });

    // return checksum address
    // https://docs.ethers.org/v5/api/utils/address/#utils-getAddress
    return ethers__WEBPACK_IMPORTED_MODULE_5__.getAddress(accounts[0]);
  }

  /**
   * @returns The `chainId` of the currently connected chain from injected provider normalized to a `number`
   */
  async getChainId() {
    const provider = await this.getProvider();
    if (!provider) {
      throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a();
    }
    return provider.request({
      method: "eth_chainId"
    }).then(_dist_normalizeChainId_e4cc0175_browser_esm_js__WEBPACK_IMPORTED_MODULE_6__.n);
  }

  /**
   * get the injected provider
   */
  async getProvider() {
    const provider = this.options.getProvider();
    if (provider) {
      (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, _provider, provider);
      // setting listeners
    }

    return (0,_dist_classPrivateFieldSet_a5db7c83_browser_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, _provider);
  }

  /**
   * get a `signer` for given `chainId`
   */
  async getSigner() {
    let {
      chainId
    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const [provider, account] = await Promise.all([this.getProvider(), this.getAccount()]);

    // ethers.providers.Web3Provider
    return new ethers__WEBPACK_IMPORTED_MODULE_8__.Web3Provider(provider, chainId).getSigner(account);
  }

  /**
   *
   * @returns `true` if the connector is connected and address is available, else `false`
   */
  async isAuthorized() {
    try {
      // `false` if connector is disconnected
      if (this.options.shimDisconnect &&
      // If shim does not exist in storage, wallet is disconnected
      !Boolean(await this.connectorStorage.getItem(this.shimDisconnectKey))) {
        return false;
      }
      const provider = await this.getProvider();
      if (!provider) {
        throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a();
      }
      // `false` if no account address available, else `true`
      const account = await this.getAccount();
      return !!account;
    } catch {
      // `false` if any error thrown
      return false;
    }
  }

  /**
   * switch to given chain
   */
  async switchChain(chainId) {
    const provider = await this.getProvider();
    if (!provider) {
      throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.a();
    }
    const chainIdHex = ethers__WEBPACK_IMPORTED_MODULE_9__.hexValue(chainId);
    try {
      // request provider to switch to given chainIdHex
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: chainIdHex
        }]
      });
      const chain = this.chains.find(_chain => _chain.chainId === chainId);
      if (chain) {
        return chain;
      }
      return {
        chainId: chainId,
        name: `Chain ${chainIdHex}`,
        slug: `${chainIdHex}`,
        nativeCurrency: {
          name: "Ether",
          decimals: 18,
          symbol: "ETH"
        },
        rpc: [""],
        chain: "",
        shortName: "",
        testnet: true
      };
    } catch (error) {
      // if could not switch to given chainIdHex

      // if tried to connect to a chain that is not configured
      const chain = this.chains.find(_chain => _chain.chainId === chainId);
      if (!chain) {
        throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.C({
          chainId,
          connectorId: this.id
        });
      }

      // if chain is not added to provider
      if (error.code === 4902 ||
      // Unwrapping for MetaMask Mobile
      // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
      error?.data?.originalError?.code === 4902) {
        try {
          // request provider to add chain
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: chainIdHex,
              chainName: chain.name,
              nativeCurrency: chain.nativeCurrency,
              rpcUrls: chain.rpc,
              blockExplorerUrls: this.getBlockExplorerUrls(chain)
            }]
          });
          return chain;
        } catch (addError) {
          // if user rejects request to add chain
          if (this.isUserRejectedRequestError(addError)) {
            throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.U(error);
          }

          // else other error
          throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.A();
        }
      }
      if (this.isUserRejectedRequestError(error)) {
        throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.U(error);
      }
      throw new _dist_errors_4bdf81d2_browser_esm_js__WEBPACK_IMPORTED_MODULE_7__.S(error);
    }
  }
  async setupListeners() {
    const provider = await this.getProvider();
    if (provider.on) {
      provider.on("accountsChanged", this.onAccountsChanged);
      provider.on("chainChanged", this.onChainChanged);
      provider.on("disconnect", this.onDisconnect);
    }
  }
  isUserRejectedRequestError(error) {
    return error.code === 4001;
  }
}




/***/ }),

/***/ "./node_modules/@thirdweb-dev/wallets/evm/connectors/trust/dist/thirdweb-dev-wallets-evm-connectors-trust.browser.esm.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@thirdweb-dev/wallets/evm/connectors/trust/dist/thirdweb-dev-wallets-evm-connectors-trust.browser.esm.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TrustConnector: () => (/* binding */ TrustConnector)
/* harmony export */ });
/* harmony import */ var _injected_dist_thirdweb_dev_wallets_evm_connectors_injected_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/evm/connectors/injected/dist/thirdweb-dev-wallets-evm-connectors-injected.browser.esm.js");
/* harmony import */ var _dist_assertWindowEthereum_66ccef46_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../dist/assertWindowEthereum-66ccef46.browser.esm.js */ "./node_modules/@thirdweb-dev/wallets/dist/assertWindowEthereum-66ccef46.browser.esm.js");
/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ "./node_modules/eventemitter3/index.mjs");











class TrustConnector extends _injected_dist_thirdweb_dev_wallets_evm_connectors_injected_browser_esm_js__WEBPACK_IMPORTED_MODULE_0__.InjectedConnector {
  constructor(arg) {
    const defaultOptions = {
      name: "Trust",
      getProvider() {
        function getReady(ethereum) {
          const isTrust = !!ethereum?.isTrust;
          if (!isTrust) {
            return;
          }
          return ethereum;
        }
        if ((0,_dist_assertWindowEthereum_66ccef46_browser_esm_js__WEBPACK_IMPORTED_MODULE_2__.a)(globalThis.window)) {
          if (globalThis.window.ethereum?.providers) {
            return globalThis.window.ethereum.providers.find(getReady);
          }
          return getReady(globalThis.window.ethereum);
        }
      }
    };
    const options = {
      ...defaultOptions,
      ...arg.options
    };
    super({
      chains: arg.chains,
      options,
      connectorStorage: arg.connectorStorage
    });
  }
}




/***/ })

}]);